---
title: "ERA-interim"
output: html_notebook
---


```{r}
library(tidyverse)
library(lubridate)
library(mongolite)
library(raster)
library(tmap)
library(grid)
```

Choose which ERA-interim version. High resolution (0.25°) or Low resolution (2.5°)

```{r}
ERA_vers <- c('lores', 'hires')[1]
col_grid <- sprintf('ERAINT_%s_grid', ERA_vers)
col_dat <- sprintf('ERAINT_%s_monthly', ERA_vers)
```


Connect to mongodb

```{r}
con_grid <- mongo(collection = col_grid, db = 'ECMWF', verbose = F)
con_data <- mongo(collection = col_dat, db = 'ECMWF',verbose = F)
```

Examine indexes

```{r}
con_grid$index()
con_data$index()
```

- The domain north of 20°N is chosen for EOF decomposition for Z70 hPa and SIC to focus on the extra-tropical variability 
- The area north of 20°S is chosen for SST to also include key regions of tropical SST variability

Query id_grid encompassed in the domain. Be careful: defining a simple box won't work on the sphere, see [Antimeridian Cutting](https://tools.ietf.org/html/rfc7946#section-3.1.9). In addition, a vertice will follow the shorterst path on the sphere. Hence, we need to define a proper circular path for both latmin and latmax.

```{r}
this_box <- list(lonmin = -180, lonmax = 180, latmin = 20, latmax = 90)

genCircle <- function(start_lon, stop_lon , lat, decreasing = F){
  seq(from = start_lon, to = stop_lon) %>% sort(., decreasing = decreasing) %>% 
  map_chr(.x = ., .f = function(x){
    paste0('[', x , ',', lat,']')
    }) %>% paste(., collapse = ',')
}
  
circle_north_pos <- genCircle(start_lon = this_box$lonmin, stop_lon = this_box$lonmax, 
                              lat = this_box$latmax, decreasing = F)
circle_south_neg <- genCircle(start_lon = this_box$lonmin, stop_lon = this_box$lonmax, 
                            lat = this_box$latmin,  decreasing = T)

slp_poly <- sprintf("[[%s,%s], %s, %s]",
                    this_box$lonmin, this_box$latmin,
                    circle_north_pos,
                    circle_south_neg)
```


```{r}
geo_qry <-  sprintf('{"loc": 
           {"$geoWithin": {
               "$geometry": {
                   "type": "Polygon","coordinates": [%s]
             }
           }}}', slp_poly)
con_grid$count(query = geo_qry)
```

Create grid_df data_frame:

```{r}
res <-  con_grid$find(query = geo_qry, 
                      fields = '{"_id":0, "id_grid": 1, "loc": 1}')
grid_df <-  map_df(1:nrow(res),function(i){
  data_frame(id_grid = res$id_grid[i], 
             lng = res$loc$coordinates[[i]][1], 
             lat = res$loc$coordinates[[i]][2])})
grid_df %>% head()
```

Query SLP in the data collection for a given day for the grid_ids

```{r}
# Query SLP in the data collection for a given day for the grid_ids
this_date <- "1988-12-01"
this_gridids <- paste(grid_df$id_grid, collapse = ',')
qry <- sprintf('{
    "date": {"$date": "%sT00:00:00Z" },
    "id_grid": {"$in": [%s]}}', this_date, this_gridids)
res <- con_data$find(query = qry,
    fields = '{"_id":0, "id_grid": 1, "msl": 1}') %>% as_data_frame()
slp_dat <- res %>% left_join(grid_df, by = 'id_grid')
slp_dat %>% head()
```

Rasterize and visualize:

```{r}
grid_dat <- slp_dat
# Create a raster
pts <- dplyr::select(grid_dat, lng, lat) %>% SpatialPoints()
projection(pts) <- "+proj=longlat"
pix <- SpatialPixelsDataFrame(pts, #tolerance = 0.5, 
                              data = grid_dat)
ras <- raster(pix['msl'])
ras
#plot(ras)      
```

Plot the SLP field :

```{r}
polar_proj <- tmaptools::get_proj4('+proj=stere +lon 0=90w', as.CRS = T)
data("World")
tm_shape(ras) + 
  tm_raster(palette = "YlGnBu")+
  tm_shape(World, is.master = TRUE)+
  tm_borders()
```

Using a nicer cartographic Polar projection:

```{r}
plotPolar <- function(ras){
  polar_proj <- tmaptools::get_proj4('+proj=laea +lon_0=0e +lat_0=90n', as.CRS = T)
  data("World")
  p <- tm_shape(ras, projection = polar_proj, is.master = T) +
    tm_raster(palette = "YlGnBu") +
    tm_layout(legend.text.size = 0.4,
          legend.position = c("left","top")) +
    tm_shape(World, is.master = F) + 
    tm_borders()
  return(p)
}
plotPolar(ras)
```


# Empirical Orthogonal Function Analysis

Let us extract data only for Autumn and Winter months and above LAT 20°N.

```{r}
pip <- sprintf('[ {"$project": {"id_grid": 1, "date": 1, "msl": 1, "month": {"$month": "$date"}}},
                  {"$match": {"month": {"$in": [9, 10, 11, 12, 1, 2]},
                              "id_grid": {"$in": [%s]} }},
                  {"$project": {"_id": 0, "id_grid": 1, "date": 1, "msl": 1}} ]', this_gridids)
res <- con_data$aggregate(pipeline = pip)
```

Transform in Matrix-like format suited for PCA

```{r}
dat <- res %>% spread(key = id_grid, value = msl) %>% as_data_frame()
head(dat)
```

Actually, the number of grid cell is too large in comparison with the number of monthly observations. This leads to a singular covariance matrix, impossible to invert.

```{r}
dim(dat)
38*6
```

```{r}
pca <- prcomp(x = dat %>% dplyr::select(-date), center = T)
str(pca)
```

Plot the first mode of variability :

Rasterize data: 
(i) format to data_frame:
```{r}
eof <- data_frame(id_grid= colnames(dat %>% dplyr::select(-date)) %>% as.integer(), 
                  eof1 = pca$rotation[,1],
                  eof2 = pca$rotation[,2],
                  eof3 = pca$rotation[,3],
                  eof4 = pca$rotation[,4])
                  
eof_df <- grid_df %>% left_join(eof)
head(eof_df)
```

(ii) rasterize data from data_frame:

```{r}
grid_dat <- eof_df
# Create a raster
pts <- dplyr::select(grid_dat, lng, lat) %>% SpatialPoints()
projection(pts) <- "+proj=longlat"
pix <- SpatialPixelsDataFrame(pts, #tolerance = 0.5, 
                              data = grid_dat)
eof1 <- raster(pix['eof1'])
eof2 <- raster(pix['eof2'])
eof3 <- raster(pix['eof3'])
eof4 <- raster(pix['eof4'])


p1 <- plotPolar(ras = eof1)
p2 <- plotPolar(ras = eof2)
p3 <- plotPolar(ras = eof3)
p4 <- plotPolar(ras = eof4)

grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 2)))
print(p1, vp=viewport(layout.pos.row =1, layout.pos.col = 1))
print(p2, vp=viewport(layout.pos.row =1, layout.pos.col = 2))
print(p3, vp=viewport(layout.pos.row =2, layout.pos.col = 1))
print(p4, vp=viewport(layout.pos.row =2, layout.pos.col = 2))

```

Plot of explained variances :

```{r}
cutoff <- 10
exVar <- data_frame(eof = 1:cutoff, 
                    exVar = pca$sdev[1:cutoff]^2/sum(pca$sdev^2),
                    totalExpl = map_dbl(.x = 1:cutoff, .f = function(x) sum(exVar[1:x])))
exVar
```

These plots do not corresponds to Wang et al. (nat, 2017) because we have used Mean Sea-Level Pressure. Wang et al. (2017) are using geopotential height at 70hPa. We need to load this variable into mongodb and repeat the analysis. 

When it's done, let's explore again the data.

```{r}
this_variable <- 'z70'
this_gridids <- paste(grid_df$id_grid, collapse = ',')
pip <- sprintf('[ {"$project": {"id_grid": 1, "date": 1, "%s": 1, "month": {"$month": "$date"}}},
                  {"$match": {"month": {"$in": [9, 10, 11, 12, 1, 2]},
                              "id_grid": {"$in": [%s]} }},
                  {"$project": {"_id": 0, "id_grid": 1, "date": 1, "%s": 1}} ]', 
               this_variable,
               this_gridids,
               this_variable)
res <- con_data$aggregate(pipeline = pip)
```
Manipulations:


```{r}
dat <- res %>% spread(key = id_grid, value = z70) %>% as_data_frame()
pca <- prcomp(x = dat %>% dplyr::select(-date), center = T)
eof <- data_frame(id_grid= colnames(dat %>% dplyr::select(-date)) %>% as.integer(), 
                  eof1 = pca$rotation[,1],
                  eof2 = pca$rotation[,2],
                  eof3 = pca$rotation[,3],
                  eof4 = pca$rotation[,4])
eof_df <- grid_df %>% left_join(eof)
# Create a raster
pts <- dplyr::select(eof_df, lng, lat) %>% SpatialPoints()
projection(pts) <- "+proj=longlat"
pix <- SpatialPixelsDataFrame(pts, #tolerance = 0.5, 
                              data = eof_df)
eof1 <- raster(pix['eof1'])
eof2 <- raster(pix['eof2'])
eof3 <- raster(pix['eof3'])
eof4 <- raster(pix['eof4'])
p1 <- plotPolar(ras = eof1)
p2 <- plotPolar(ras = eof2)
p3 <- plotPolar(ras = eof3)
p4 <- plotPolar(ras = eof4)
grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 2)))
print(p1, vp=viewport(layout.pos.row =1, layout.pos.col = 1))
print(p2, vp=viewport(layout.pos.row =1, layout.pos.col = 2))
print(p3, vp=viewport(layout.pos.row =2, layout.pos.col = 1))
print(p4, vp=viewport(layout.pos.row =2, layout.pos.col = 2))
```


```{r}
plotPolar(eof1)
```

